using System;
using System.Diagnostics;
using System.Drawing;
using System.Windows.Forms;

namespace GS1Validator
{
    /// <summary>
    /// Textbox with automatically parsing GS1 barcodes after set period of time.
    /// </summary>
    /// TODO: instead of having a separate barcode found event, we should override the text changed and only throw it after the delay
    public sealed class TextBoxBarcode : TextBox
    {
        private readonly Timer _timerProcessInput = new Timer();
        private bool _canClear;
        private readonly Stopwatch _st = new Stopwatch();

        public event EventHandler BarcodeRecieved;

        public TimeSpan Delay { get; set; } = TimeSpan.FromSeconds(.5);
        public TimeSpan BarcodeRecievedTime { get; set; } = TimeSpan.FromSeconds(1);

        /// <summary>
        /// Initializes a new instance of the <see cref="TextBoxBarcode"/> class.
        /// </summary>
        /// <autogeneratedoc />
        public TextBoxBarcode()
        {
            ReadOnly = true;
            _timerProcessInput.Tick += timerProcessInput_Tick;
            _timerProcessInput.Interval = (int)BarcodeRecievedTime.TotalMilliseconds;
            GotFocus += (sender, args) =>
            {
                BackColor = Color.Yellow;
            };
            LostFocus += (sender, args) => { ResetBackColor(); };
        }





        /// <param name="e">An <see cref="T:System.EventArgs"/> that contains the event data. </param>
        protected override void OnTextChanged(EventArgs e)
        {
            base.OnTextChanged(e);
            RestartTimer();
        }

        /// <summary>
        /// Raises the <see cref="E:System.Windows.Forms.Control.KeyPress"/> event.
        /// </summary>
        /// <param name="e">A <see cref="T:System.Windows.Forms.KeyPressEventArgs"/> that contains the event data. </param>
        protected override void OnKeyPress(KeyPressEventArgs e)
        {
            _st.Stop();
            base.OnKeyPress(e);
            e.Handled = true;

            if (_canClear)
            {
                Clear();
                _canClear = false;
            }
            Text += e.KeyChar;

            if (_st.Elapsed.TotalMilliseconds > Delay.TotalMilliseconds)
            {

                _canClear = true;
                Clear();

            }

            _st.Restart();
        }

        private void RestartTimer()
        {
            _timerProcessInput.Stop();
            _timerProcessInput.Start();
        }
        private void timerProcessInput_Tick(object sender, EventArgs e)
        {
            OnBarcodeRecieved();
            _canClear = true;
        }

        private void OnBarcodeRecieved()
        {
            _st.Stop();
            _st.Reset();
            _timerProcessInput.Stop();
            BarcodeRecieved?.Invoke(this, EventArgs.Empty);
        }
    }
}
